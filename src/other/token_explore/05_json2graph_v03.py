# Python 2.7

import json
## TJR--------------------------------------------------------------------------------
##
##  This import fails on my machine
##
## TJR--------------------------------------------------------------------------------
from datetime import datetime
from datetime import timedelta
import matplotlib.pyplot as plt
import re
import progressbar

def timestamp2human(timestamp):
    human = datetime(1970, 1, 1, 00, 00) + timedelta(seconds=timestamp)
    return human

# serialize datetime formats
def myconverter(o):
    if isinstance(o, datetime):
        return o.__str__()

def daterange(date1, date2):
    for n in range(int ((date2 - date1).days)+1):
        yield date1 + timedelta(n)

fileName = 'newbium.json'
totalSupply = 49000000
ctrAddress = '0x814964b1bceaf24e26296d031eadf134a2ca4105'
ctrTxHash = '0x03047f8e573880f822964804846bf866f7a2c33c80328da285f9d2a984edab1d'
Balances = []
TimeStamps = []

print "Abriendo JSON..."
with open(fileName) as f:
    txs = json.load(f)
print "Buscando accionistas, eventos y transferencias..."

holders = []
cnames = []

oldestEvent = datetime(2070, 1, 1, 00, 00)
newestEvent = datetime(1970, 1, 1, 00, 00)

## TJR--------------------------------------------------------------------------------
##
##  `cname` is now found at `articulatedTx.name` for the transaction and
##  `articulatedLog.name` for the events. Also, these events now have the
##  word `Event` at the end. For example, `TransferEvent` not `Transfer`
##
## TJR--------------------------------------------------------------------------------
cnameList = ['WithdrawToken', 'DepositToken', 'TransferFrom', 'Transfer']

## TJR--------------------------------------------------------------------------------
##
##  Contract creations, if sucessful, appear in the field receipt.contractAddress.
##  The only time this field will be non-empty is when a contract has been created.
##  Another hint is that the transaction's `to` address will be `0x0`
##
## TJR--------------------------------------------------------------------------------
for tx in txs:
    if tx['cname'] == 'Transaction' and tx['hash'] == ctrTxHash:
        creatorBlock = tx['blockNumber']
        contract = tx['receipt']['contractAddress']
        ## TJR--------------------------------------------------------------------------------
        ##
        ##  Calling this a 'hash' could be confusing. I would call it an `creatorAddr`.
        ##  Personal preference.
        ##
        ## TJR--------------------------------------------------------------------------------
        creatorHash = tx['from']
        creatorTimeStamp = tx['timestamp']
        oldestEvent = timestamp2human(tx['timestamp'])
        break

bar = progressbar.ProgressBar(maxval=len(txs), \
    widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])
bar.start()

for i,tx in enumerate(txs):
    ## TJR--------------------------------------------------------------------------------
    ##
    ##  `cname` is now found in `articulatedTx.name`
    ##
    ## TJR--------------------------------------------------------------------------------
    if tx['cname'] in cnameList:

        ## TJR--------------------------------------------------------------------------------
        ##
        ##  receipt.events has been renamed receipt.logs
        ##
        ## TJR--------------------------------------------------------------------------------
        for log in tx['receipt']['events']:

            ## TJR--------------------------------------------------------------------------------
            ##
            ##  The next line will correctly identify events generated by the address of interest
            ##
            ## TJR--------------------------------------------------------------------------------
            if log['address'] == ctrAddress:

                ## TJR--------------------------------------------------------------------------------
                ##
                ##  Events are now articulated, so you can pick up these values from the articulatedLog
                ##  data as in this example:
                ##
                ##          "articulatedLog": [
                ##            {
                ##              "name": "TransferEvent",
                ##              "inputs": [
                ##                {
                ##                  "name": "_from",
                ##                  "value": "0xc9d7fec9889690bbff0a0df758d13e5a55dd7822"
                ##                },
                ##                {
                ##                  "name": "_to",
                ##                  "value": "0x7e07224ecd8b4be9ebba3556bb15b2b7f4d77b9a"
                ##                },
                ##                {
                ##                  "name": "_value",
                ##                  "value": "8800000"
                ##                }
                ##             ]
                ##           }
                ##
                ##  Also, importantly, `topics` and `data` are now hidden by default. You may turn them
		##  back on with the [fields]show= option in the config file.
                ##
                ## TJR--------------------------------------------------------------------------------
                # check if holder is already in holders array
                holderFrom = re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', log['topics'][1])
                holderTo   = re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', log['topics'][2])

                ## TJR--------------------------------------------------------------------------------
                ##  Adding the holderFrom if not already in the list of holders
                ## TJR--------------------------------------------------------------------------------
                if holderFrom not in holders:
                    holders.append(holderFrom)
                    Balances.append([])
                    TimeStamps.append([])
                    TimeStamps[-1].append(timestamp2human(creatorTimeStamp))
                    ## TJR--------------------------------------------------------------------------------
                    ##  The accounting below is only possible because you know the Solidity source code
                    ##  I've always tried to write code that doesn't require me to know anything about
                    ##  the solidity code. If you’re running a full node, you can query the `totalSupply`
		    ##  from the contract itself. I’m working on adding that functionality to QuickBlocks.
                    ## TJR--------------------------------------------------------------------------------
                    if holderFrom == re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', creatorHash):
                        Balances[-1].append(totalSupply)
                    else:
                        Balances[-1].append(0)

                ## TJR--------------------------------------------------------------------------------
                ##  Adding the holderTo if not already in the list of holders
                ## TJR--------------------------------------------------------------------------------
                if holderTo not in holders:
                    holders.append(holderTo)
                    Balances.append([])
                    TimeStamps.append([])
                    TimeStamps[-1].append(timestamp2human(creatorTimeStamp))
                    if holderTo == re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', creatorHash):
                        Balances[-1].append(totalSupply)
                    else:
                        Balances[-1].append(0)

                if holderFrom in holders:
                    index = holders.index(holderFrom)
                    Balances[index].append(Balances[index][-1])
                    ## TJR--------------------------------------------------------------------------------
                    ##
                    ##  I'm not sure, so you should double check, but one of the reasons you may be getting
                    ##  negative balances is your use of the `data` field. Is the first item in the `data`
                    ##  field of WithdrawlTokenEvent, DepositTokenEvent, TransferFromEvent and TransferEvent
                    ##  always an `amount`? Plus, another very important reason you may be getting weird
		    ##  balances may be because you’re converting to an ‘int’.  Is an ‘int’ big enough?
		    ##  You may be truncating value here (or overflowing). The ‘value’ fields in this
		    ##  data are ‘big numbers’. They are in Wei which can be very large (much larger than
		    ##  an ‘int’.  Again, I’m not sure, but you should check.  Do this: write a small program
		    ##  that reads all the data and then looks at the transaction.value. Convert the to an
		    ##  ‘int’ to see if the output is the same as the input. I know in JavaScript (and C++)
		    ##  you have to use big numbers.
                    ##
                    ## TJR--------------------------------------------------------------------------------
                    Balances[index].append(Balances[index][-1]-int(log['data'],0))
                    TimeStamps[index].append(timestamp2human(tx['timestamp']))
                    ## TJR--------------------------------------------------------------------------------
                    ##  duplicate line???
                    ## TJR--------------------------------------------------------------------------------
                    TimeStamps[index].append(timestamp2human(tx['timestamp']))

                if holderTo in holders:
                    index = holders.index(holderTo)
                    Balances[index].append(Balances[index][-1])
                    ## TJR--------------------------------------------------------------------------------
                    ##  Same comment as above about `data` field.
                    ## TJR--------------------------------------------------------------------------------
                    Balances[index].append(Balances[index][-1]+int(log['data'],0))
                    TimeStamps[index].append(timestamp2human(tx['timestamp']))
                    TimeStamps[index].append(timestamp2human(tx['timestamp']))

                if timestamp2human(tx['timestamp']) > newestEvent:
                    newestEvent = timestamp2human(tx['timestamp'])

    ## TJR--------------------------------------------------------------------------------
    ##  Is this identical code for handling the 'Transaction' type? Why not just add that
    ##  to the list `cnames` list? I'm not sure I understand what this code does.
    ## TJR--------------------------------------------------------------------------------
    elif tx['cname'] == 'Transaction':
        for log in tx['receipt']['events']:
            if log['address'] == ctrAddress:

                # check if holder is already in holders array
                try:
                    holderFrom = re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', log['topics'][1])
                    holderTo = re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', log['topics'][2])
                    continuing = True
                except:
                    continuing = False

                if continuing == True:
                    if holderFrom not in holders:
                        holders.append(holderFrom)
                        Balances.append([])
                        TimeStamps.append([])
                        TimeStamps[-1].append(timestamp2human(creatorTimeStamp))
                        if holderFrom == re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', creatorHash):
                            Balances[-1].append(1)
                        else:
                            Balances[-1].append(0)
                    if holderTo not in holders:
                        holders.append(holderTo)
                        Balances.append([])
                        TimeStamps.append([])
                        TimeStamps[-1].append(timestamp2human(creatorTimeStamp))
                        if holderTo == re.sub('(0x)(000000000000000000000000)(.*)', r'\1\3', creatorHash):
                            Balances[-1].append(1)
                        else:
                            Balances[-1].append(0)

                    if holderFrom in holders:
                        index = holders.index(holderFrom)
                        Balances[index].append(Balances[index][-1])
                        Balances[index].append(Balances[index][-1]-int(log['data'],0))
                        TimeStamps[index].append(timestamp2human(tx['timestamp']))
                        TimeStamps[index].append(timestamp2human(tx['timestamp']))

                    if holderTo in holders:
                        index = holders.index(holderTo)
                        Balances[index].append(Balances[index][-1])
                        Balances[index].append(Balances[index][-1]+int(log['data'],0))
                        TimeStamps[index].append(timestamp2human(tx['timestamp']))
                        TimeStamps[index].append(timestamp2human(tx['timestamp']))

    elif tx['cname'] not in cnames:
        cnames.append(tx['cname'])

    bar.update(i+1)

bar.finish()

## TJR--------------------------------------------------------------------------------
##
##  It appears you're done with the QuickBlocks data here, so I won't comment further
##
## TJR--------------------------------------------------------------------------------

timeLine = []
fundingPath = []
fundingPathPrint = []

oldestEvent = oldestEvent.replace(hour=0, minute=0, second=0, microsecond=0)
newestEvent = newestEvent.replace(hour=0, minute=0, second=0, microsecond=0)

for dt in daterange(oldestEvent, newestEvent):
    timeLine.append(dt)
    fundingPath.append(0)

print "\n"
print cnames
print "Preparando gráfico..."
total = 0
colours=['r','g','b','k']
m=0

percentages = []
address = []

for i, blc in enumerate(Balances):
    if holders[i] != "0x0000000000000000000000000000000000000000":
        total += blc[-1]
        # don't show small fish
        if blc[-1] > 0.01*totalSupply:
            percentages.append(blc[-1])
            address.append(holders[i])
        printing = False
        for j, item in enumerate(blc):
            index = timeLine.index(TimeStamps[i][j].replace(hour=0, minute=0, second=0, microsecond=0))
            if int(item) < 0.15*totalSupply:
                if j > 0:
                    appendItem = blc[j-1]
                else:
                    appendItem = item
                fundingPath[index] += int(appendItem)
            if item > 0.01*totalSupply:
                printing = True
            if item < 0:
                print holders[i], item
                print len(blc)
        # this would add another entry to have a line from the last tx to today
        #Balances[i].append(blc[-1])
        #TimeStamps[i].append(datetime.now())
        if blc[-1] > 0.05*totalSupply:
            print holders[i], blc[-1]
        if blc[-1] < 0:
            print holders[i], blc[-1]
        # this would plot the balance over time
        if printing == True:
            # ax = plt.plot(TimeStamps[i], Balances[i], colours[m])
            m+=1
        if m>3:
            m = 0

# funding path graph
for day in fundingPath:
    if fundingPathPrint != []:
        fundingPathPrint.append(fundingPathPrint[-1]+float(day)/totalSupply)
    else:
        fundingPathPrint.append(float(day)/totalSupply)

"""
jsonoutH = json.dumps(holders, default = myconverter)
jsonoutB = json.dumps(Balances, default = myconverter)
jsonoutT = json.dumps(TimeStamps, default = myconverter)


with open('newbiumoutH.json', 'w') as outfile:
    json.dump(jsonoutH, outfile)
with open('newbiumoutB.json', 'w') as outfile:
    json.dump(jsonoutB, outfile)
with open('newbiumoutT.json', 'w') as outfile:
    json.dump(jsonoutT, outfile)
"""

for i, pct in enumerate(percentages):
    print pct/totalSupply, address[i]
print "\n"
print "Suma de balances: " + str(total)
print "Total supply:          " + str(totalSupply)

axe = plt.plot(timeLine, fundingPathPrint)
plt.show()
